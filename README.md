## 正则表达式

### 正则表示基本用法

#### 元字符-字符匹配符
| 符号  | 含义        | 示例     | 解释            |
|-----|-----------|--------|---------------|
| []  | 可接收的字符列表  | [abc]  | a,b,c中的任意一个字符 |
| [^] | 不可接收的字符列表 | [^abc] | 不可接收字符：a,b,c  |
| -   | 连字符       | [a-z]  | a到z之间的任意小写字符  |

| 符号 | 含义 |
|-----|------|
|\\d|匹配任意一个数字字符|
|\\D|匹配任意一个非数字字符|
|\\w|匹配大小写字母，数字，下划线中的任意一个|
|\\W|匹配除大小写字母，数字，下划线之外的任意字符|
|\\s|匹配任意空格|
|\\S|匹配非空格符|

#### 元字符-选择符
| 符号  | 含义   |
|-----|------|
| (a) | (b)  | 匹配a或者b |

#### 元字符-限定符
| 符号     | 含义           |
|--------|--------------|
| a+     | 匹配至少一个a      |
| a*     | 匹配0个或者多个a    |
| a?     | 匹配0个或者1个a    |
| a{n}   | 匹配n个a        |
| a{n,m} | 匹配至少n个，之多m个a |
| a{n,}  | 匹配至少n个a      |
| a{,n}  | 匹配之多n个a      |

#### 元字符-定位符
| 符号      | 含义                |
|---------|-------------------|
| ^[a-z]+ | 匹配一个或多个小写字母开头的字符  |
| [0-9]+$ | 匹配一个或多个数字结尾的字符    |
| han\\b  | 匹配义han为字符边界的han   |
| han\\B  | 匹配han但是han不能是字符边界 |

#### 正则表达式-捕获分组
| 分组构造形式           | 解释                                                                |
|------------------|-------------------------------------------------------------------|
| (pattern)        | 非命名捕获：捕获匹配的子字符串。编号为0的第一个捕获由整个正则表达式模式匹配的文本，其他捕获结果则根据左括号的顺序从2开始自动编号 |
| (?<name>pattern) | 命名捕获：                                                             |

#### 正则表达式-非捕获分组
| 分组形式        | 解释                                                                                                                          |
|-------------|-----------------------------------------------------------------------------------------------------------------------------|
| (?:pattern) | 匹配pattern但不捕获该匹配的子表达式，即他是一个非捕获匹配，不存储供以后使用的匹配。这遂于用“or"字符（ \|）组合模式部件的情况很有用。例如：'industr(?:y\|ies)'是比industry \|industies更经的表达式 |
| (?=pattern) | 它是一个非捕获匹配。例如：'Windows(95\|98\|NT\|2000)'匹配Windows2000中的Windows，但是不匹配”Windows3.1中的Windows                                    |
| (?!pattern) | 与(?=pattern)相反                                                                                                              |
***Java中的匹配算法都是贪婪算法***